# Graph2


# 최소 비용 신장 트리
신장 트리(spanning tree): 그래프 내의 모든 정점을 포함하는 트리
- 모든 정점들이 연결되어 있어야 하며, 사이클을 포함해서는 안됨
- n개의 정점에 대해 (n-1)개의 간선으로 연결되어 있음

<br>

최소 비용 신장 트리(MST, Minimum Spannig Tree): 네트워크에 있는 모든 정점들을 가장 적은 수의 간선과 비용으로 연결하는 트리
- 신장 트리 중에서 사용된 간선들의 가중치 합이 최소인 신장 트리

<br>


## Kruskal의 MST 알고리즘
탐욕적인 방법(greedy method) 이용
- 선택할 때마다 그 순간 가장 최적이라고 생각 되는 것을 선택


1) 최소 비용의 간선으로 구성
2) 사이클을 포함하지 않는 조건
<br>

<img src="https://user-images.githubusercontent.com/71310074/145030856-39fd1500-4c8b-44cb-a5fb-1fb135269cea.png" width="500">
<img src="https://user-images.githubusercontent.com/71310074/145008034-0dfa2c7e-d125-4f42-9f65-4469217ec22a.png" width="400">
<br>

알고리즘의 원리
1. 그래프의 간선들을 가중치의 오름차순으로 정렬 (qsort 함수 또는 최소 히프 이용)
2. 정렬된 간선들의 리스트에서 사이클을 형성하지 않는 간선을 선택하여 현재의 최소 비용 신장 트리 집합에 추가
3. 정점의 개수 n에 대하여 (n-1)개의 간선이 선택되는 순간 알고리즘 종료

<br>


### union-find 연산
- 트리 형태를 사용하여 집합을 구현
- 부모 노드의 인덱스를 저장하는 1차원 배열로 구현 (루트 노드인 경우 -1)

<br>

### Kruskal 알고리즘 분석
- union-find 연산을 위해 간선들을 정렬하는 시간에 좌우됨
- 알고리즘 시간 복잡도 : `O(|e||log2|e|)`


<br>


## Prim의 MST 알고리즘
- 시작 정점에서 출발하여, 신장 트리 집합을 단계적으로 확장해나가는 방법
- 앞 단계에서 만들어진 신장 트리 집합에, 인접한 정점들 중에서 최저 간선으로 연결된 정점을 선택하여 트리를 확장해나감 
- (n-1)개의 간선을 선택하게 될 까지 진행


<img src ="https://user-images.githubusercontent.com/71310074/145027756-9dc8ba0b-1964-4575-ba86-da91c6a7869c.png" width="500">

<br><hr>


# 최단 경로 알고리즘
- 최단 경로(shortest path): 정점 i와 정점 j를 연경하는 경로 중 간선들의 가중치 합이 최소가 되는 경로를 탐색

<br>

## Dijkstra의 최단 경로 알고리즘
- 하나의 시작 정점으로부터 다른 모든 정점까지의 최단 경로를 찾는 알고리즘
- 집합에 시작 정점으로부터의 거리가 작은 정점들을 추가하며, 해당 정점을 거쳐 다른 정점으로 가는 거리를 기존 거리와 변경하여 더 짧은 거리를 최단 경로를 변경


<img src ="https://user-images.githubusercontent.com/71310074/145030720-6695f57b-b4e8-4599-a114-e22511207c23.png" width="450">

### Dijkstra 알고리즘 분석
- 주반복문 n번, 내부 반복문 2n번 -> 시간 복잡도: `O(n^2)`


<br>


## Floyd의 최단 경로 알고리즘

<img src="https://user-images.githubusercontent.com/71310074/145032512-02a955f2-f686-4fbd-8076-76be68e80c7d.png" width="600">


- 그래프의 존재하는 모든 정점 사이의 최단 경로를 한 번에 모두 찾아주는 알고리즘
- 2차원 배열을 3중 반복 루프로 돌림
  - 정점 i에서 j까지, 정점 k를 거쳐 가는 경로가 더 짧은 경우 최단 경로 값을 변경
- 시간 복잡도: `O(n^3)`


<br><hr>


## 3. 위상 정렬 

그래프의 위상 정렬 알고리즘
- 방향 그래프에서의 `간선 <u, v>` : 정점 u는 정점 v를 선행한다.
- 위상 정렬(topological sort) : 각 정점들의 선행 순서를 위배하지 않으면서 모든 정점을 나열하는 것
- 진입 차수가 0인 정점을 선택하고, 선택된 정점과 그리고 이 정점에 부착된 모든 간선을 삭제하는 과정을 반복하여 모든 정점이 선택/삭제 되면 알고리즘 종료

<img src="https://user-images.githubusercontent.com/71310074/145035451-76a7eb3b-afba-488d-ab5b-2f69aaed3eff.png" width="500">

- 각 리스트에 연결된 노드에 저장된 값을 바탕으로 `in_degree`에 진입 차수 값들을 저장
- 각 리스트에 연결된 노드에 방문할 때마다 진입 차수 감소, 진입 차수가 0으로 변경된 노드는 스택에 저장
- 스택에서 삽입한 노드에 대해 방문 


